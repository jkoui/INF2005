<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>ACW1 Stego</title>
  <style>
    body { font-family: system-ui, Arial, sans-serif; margin: 24px; }
    fieldset { margin-bottom: 24px; }
    label { display:block; margin-top: 8px; }
    .row { display:flex; gap:24px; flex-wrap: wrap; }
    .card { border:1px solid #ddd; border-radius:12px; padding:16px; }
    .preview img, .preview audio { max-width: 320px; border:1px solid #ccc; border-radius:8px; }
    /* add this below to override for waveforms */
    .preview img.wave { max-width: 1000px; width: 100%; }
    .btn { padding:8px 14px; border-radius:8px; border:1px solid #333; background:#111; color:#fff; cursor:pointer;}
    .btn.secondary { background:#fff; color:#111; }
    .note { color:#666; font-size: 0.9em; }
    .flash { background:#ffe9e9; color:#900; padding:10px 12px; border-radius:8px; margin-bottom:16px; border:1px solid #f5b5b5;}
    table.kv { border-collapse: collapse; }
    table.kv td { padding:6px 10px; border-bottom:1px dashed #ddd; }
    table.kv td.key { color:#555; }
    .muted { color:#666; }
    h2 { margin-top: 0; }
    /* ROI rectangle styling */
    #roiCanvas { cursor: crosshair; }

    /* --- Drag & Drop --- */
    .drop-zone {
      border: 2px dashed #aaa;
      border-radius: 8px;
      padding: 20px;
      text-align: center;
      color: #666;
      margin-top: 8px;
      cursor: pointer;
      font-size: 0.9em;
    }
    .drop-zone.dragover {
      border-color: #333;
      background: #f9f9f9;
      color: #111;
    }
    .drop-zone input {
      display: none;
    }
    .drop-zone .file-name {
      margin-top: 8px;
      font-size: 0.85em;
      color: #333;
    }

    .input-group {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .note {
      text-align: center;
    }
  </style>
</head>
<body>
  <h1>ACW1 Stego</h1>
  {% with messages = get_flashed_messages() %}
    {% if messages %}
      {% for m in messages %}<div class="flash">{{ m }}</div>{% endfor %}
    {% endif %}
  {% endwith %}

  <div class="row">
    <div class="card" style="flex:1; min-width: 340px;">
      <h2>Embed (Image)</h2>
      <form action="{{ url_for('embed') }}" method="post" enctype="multipart/form-data">
        <label>Cover image (PNG/BMP):</label>
        <div class="drop-zone">Drag & drop or click
          <input required type="file" name="cover" accept=".png,.bmp,image/png,image/bmp">
          <div class="file-name"></div>
        </div>
        
        <div class="input-group">
        <label>Payload (any file):</label>
        <div class="drop-zone">Drag & drop or click
          <input required type="file" name="payload" id="payload">
          <div class="file-name"></div>
        </div>
        <p2 class="note">OR</p2>
        <label>Input Text for Payload:</label>
        <input type="text" name="additional_input" id="text_input" placeholder="Input Text" required>
        </div>

        <label>LSBs (1–8): <input type="number" name="lsb" min="1" max="8" value="1" required></label>
        <label>Key (integer): <input type="number" name="key" value="12345" required></label>

        <label>Bit-plane (for previews)</label>
        <select name="bit">
          <option value="0" selected>0 (LSB)</option>
          <option value="1">1</option>
          <option value="2">2</option>
          <option value="3">3</option>
          <option value="4">4</option>
          <option value="5">5</option>
          <option value="6">6</option>
          <option value="7">7 (MSB)</option>
        </select>

        <label>Channel (for previews)</label>
        <select name="channel">
          <option value="all" selected>All</option>
          <option value="r">Red</option>
          <option value="g">Green</option>
          <option value="b">Blue</option>
        </select>

        <!-- Region of Interest (optional) -->
        <fieldset style="margin-top:12px;">
          <legend>Region (optional)</legend>
          <label class="note">Leave blank to use the entire image.</label>

          <div class="row" style="align-items:flex-start;">
            <div style="min-width:320px;">
              <!-- Live preview for drawing a rectangle -->
              <div id="roiImgContainer" class="preview" style="position:relative; display:none; width:320px;">
                <img id="roiImg" style="max-width:320px; border:1px solid #ccc; border-radius:8px;">
                <canvas id="roiCanvas" style="position:absolute; inset:0; pointer-events:auto;"></canvas>
              </div>
              <div class="note" id="roiHelp" style="display:none; margin-top:6px;">
                Tip: Click-drag on the image to select a rectangle. Coordinates auto-fill below.
              </div>
            </div>

            <div>
              <label>X1 (left): <input type="number" name="x1" id="x1" min="0" step="1"></label>
              <label>Y1 (top):  <input type="number" name="y1" id="y1" min="0" step="1"></label>
              <label>X2 (right):<input type="number" name="x2" id="x2" min="0" step="1"></label>
              <label>Y2 (bottom):<input type="number" name="y2" id="y2" min="0" step="1"></label>

              <!-- Natural size of the selected cover (backend can use this to validate) -->
              <input type="hidden" name="nat_w" id="nat_w">
              <input type="hidden" name="nat_h" id="nat_h">

              <div class="note" id="roiMeta" style="margin-top:6px;"></div>
            </div>
          </div>
        </fieldset>

        <button class="btn" type="submit">Embed →</button>
      </form>
      <p class="note">Supports images (PNG/BMP).</p>
    </div>

    <div class="card" style="flex:1; min-width: 340px;">
      <h2>Extract (Image)</h2>
      <form action="{{ url_for('extract') }}" method="post" enctype="multipart/form-data">
        <label>Stego image (PNG/BMP):</label>
        <div class="drop-zone">Drag & drop or click
          <input required type="file" name="stego" accept=".png,.bmp,image/png,image/bmp">
          <div class="file-name"></div>
        </div>
        <label>LSBs (1–8): <input type="number" name="lsb" min="1" max="8" value="1" required></label>
        <label>Key (integer): <input type="number" name="key" value="12345" required></label>
        <button class="btn secondary" type="submit">Extract ←</button>
      </form>
    </div>
  </div>

  <div class="row">
    <div class="card" style="flex:1; min-width: 340px;">
      <h2>Embed (Audio WAV)</h2>
      <form action="{{ url_for('embed_audio') }}" method="post" enctype="multipart/form-data">
        <label>Cover audio (WAV/PCM 8/16-bit):</label>
        <div class="drop-zone">Drag & drop or click
          <input required type="file" name="cover_wav" accept=".wav,audio/wav">
          <div class="file-name"></div>
        </div>

        <label>Payload (any file):</label>
        <div class="drop-zone">Drag & drop or click
          <input required type="file" name="payload_wav">
          <div class="file-name"></div>
        </div>

        <label>LSBs (1–8): <input type="number" name="lsb" min="1" max="8" value="1" required></label>
        <label>Key (integer): <input type="number" name="key" value="12345" required></label>
        
        <!-- Region of Interest (audio) -->
        <fieldset style="margin-top:12px;">
          <legend>Region (optional)</legend>
          <label class="note">Leave blank to use the entire audio.</label>

          <div class="row" style="align-items:flex-start;">
            <div style="min-width:320px;">
              <!-- Live preview for drawing a region -->
              <div id="roiAudioContainer" class="preview" style="position:relative; display:block; width:320px; height: 60px;">
                <audio id="roiAudio" style="max-width:320px; border:1px solid #ccc; border-radius:8px; z-index: 10; cursor: pointer;" controls></audio>
                <canvas id="roiAudioCanvas" style="position:absolute; inset:0; pointer-events:none; z-index:0;"></canvas>
              </div>
              <div class="note" id="roiHelp" style="display:none; margin-top:6px;">
                Tip: Click-drag on the audio visualizer to select a region. Coordinates auto-fill below.
              </div>
            </div>

            <div>
              <label>Start time (seconds): <input type="number" name="start_time" id="start_time" min="0" step="0.1"></label>
              <label>End time (seconds):  <input type="number" name="end_time" id="end_time" min="0" step="0.1"></label>

              <!-- Natural length of the selected audio (backend can use this to validate) -->
              <input type="hidden" name="nat_length" id="nat_length">

              <div class="note" id="roiMetaAudio" style="margin-top:6px;"></div>
            </div>
          </div>
        </fieldset>

        <button class="btn" type="submit" style = "position:relative; z-index:10;">Embed (WAV) →</button>
      </form>
      <p class="note">Only uncompressed PCM WAV is supported.</p>
    </div>

    <div class="card" style="flex:1; min-width: 340px;">
      <h2>Extract (Audio WAV)</h2>
      <form action="{{ url_for('extract_audio') }}" method="post" enctype="multipart/form-data">
        <label>Stego audio (WAV/PCM):</label>
        <div class="drop-zone">Drag & drop or click
          <input required type="file" name="stego_wav" accept=".wav,audio/wav">
          <div class="file-name"></div>
        </div>

        <label>LSBs (1–8): <input type="number" name="lsb" min="1" max="8" value="1" required></label>
        <label>Key (integer): <input type="number" name="key" value="12345" required></label>
        <button class="btn secondary" type="submit">Extract (WAV) ←</button>
      </form>
    </div>
  </div>

  <div class="row">
  <div class="card" style="flex:1; min-width: 340px;">
    <h2>Embed (Video MP4)</h2>
    <form action="{{ url_for('embed_video') }}" method="post" enctype="multipart/form-data">
      <label>Cover video (MP4):</label>
      <div class="drop-zone">Drag & drop or click
        <input required type="file" name="cover_video" accept=".mp4,video/mp4">
        <div class="file-name"></div>
      </div>

      <label>Payload (any file):</label>
      <div class="drop-zone">Drag & drop or click
        <input required type="file" name="payload_video">
        <div class="file-name"></div>
      </div>

      <label>Method:</label>
      <select name="method" required>
        <option value="iframe" selected>I-frame (video)</option>
      </select>

      <label>LSBs (1–8): <input type="number" name="lsb" min="1" max="8" value="1" required></label>
      <label>Key (integer): <input type="number" name="key" value="12345" required></label>

      <button class="btn" type="submit">Embed (Video) →</button>
    </form>
    <p class="note">Supports MP4 video.</p>
  </div>

  <div class="card" style="flex:1; min-width: 340px;">
    <h2>Extract (Video MP4)</h2>
    <form action="{{ url_for('extract_video') }}" method="post" enctype="multipart/form-data">
      <label>Stego video (MP4):</label>
      <div class="drop-zone">Drag & drop or click
          <input type="file" name="stego_video" accept=".mp4,.mov,.mkv">
        <div class="file-name"></div>
      </div>

      <label>Method:</label>
      <select name="method" required>
        <option value="iframe" selected>I-frame</option>
      </select>

      <label>LSBs (1–8): <input type="number" name="lsb" min="1" max="8" value="1" required></label>
      <label>Key (integer): <input type="number" name="key" value="12345" required></label>

      <button class="btn secondary" type="submit">Extract (Video) ←</button>
    </form>
  </div>
</div>


  {% if result %}
    <hr>
    <h2>Result</h2>
    <div class="row">
      {% if result.cover_preview %}
        <div class="card preview">
          <h3>Cover image preview</h3>
          <img src="{{ result.cover_preview }}">
          {% if result.cover_meta %}
            <p class="muted">{{ result.cover_meta }}</p>
          {% endif %}
        </div>
      {% endif %}

      {% if result.stego_preview %}
        <div class="card preview">
          <h3>Stego image preview</h3>
          <img src="{{ result.stego_preview }}">
        </div>
      {% endif %}

      {% if result.overlay_preview %}
        <div class="card preview">
          <h3>Change Overlay (LSB changes)</h3>
          <img src="{{ result.overlay_preview }}" alt="Change overlay">
          <p class="muted">Red = pixels with altered LSBs</p>
        </div>
      {% endif %}

      {% if result.lsb_preview %}
        <div class="card preview">
          <h3>LSB-plane preview</h3>
          <img src="{{ result.lsb_preview }}">
        </div>
      {% endif %}

      {% if result.bit_plane_preview %}
        <div class="card preview">
          <h3>Single bit-plane preview</h3>
          <img src="{{ result.bit_plane_preview }}">
        </div>
      {% endif %}

      {% if result.change_mask_preview %}
        <div class="card preview">
          <h3>LSB change mask</h3>
          <img src="{{ result.change_mask_preview }}">
        </div>
      {% endif %}

      {% if result.diff_preview %}
        <div class="card preview">
          <h3>Difference preview</h3>
          <img src="{{ result.diff_preview }}">
        </div>
      {% endif %}

      {% if result.cover_audio_preview %}
        <div class="card preview">
          <h3>Cover audio preview</h3>
          <audio controls src="{{ result.cover_audio_preview }}"></audio>
          {% if result.audio_meta %}
            <p class="muted">{{ result.audio_meta }}</p>
          {% endif %}
        </div>
      {% endif %}

      {% if result.stego_audio_preview %}
        <div class="card preview">
          <h3>Stego audio preview</h3>
          <audio controls src="{{ result.stego_audio_preview }}"></audio>
          {% if result.audio_diff_note %}
            <p class="muted">{{ result.audio_diff_note }}</p>
          {% endif %}
        </div>
      {% endif %}

      {% if result.chi_heatmap_preview %}
        <div class="card preview">
          <h3>Chi-Square Heatmap (Pairs-of-Values)</h3>
          <img src="{{ result.chi_heatmap_preview }}" alt="Chi-Square heatmap">
          <p class="muted">
            Red = blocks where (cover χ² − stego χ²) is high ⇒ pairs look equalized in stego (suspicious).
          </p>
        </div>
      {% endif %}

      {% if result.waveform_full_preview %}
        <div class="card preview">
          <h3>Waveform (Full Overview)</h3>
          <img class="wave" src="{{ result.waveform_full_preview }}" alt="Waveform overview">
          <p class="muted">Gray = cover, Red = stego, Blue = (stego − cover).</p>
        </div>
      {% endif %}

      {% if result.waveform_zoom_preview %}
        <div class="card preview">
          <h3>Waveform (Zoomed)</h3>
          <img class="wave" src="{{ result.waveform_zoom_preview }}" alt="Waveform zoom">
          <p class="muted">Zoomed window; uses ROI time range if provided.</p>
        </div>
      {% endif %}

      {% if result.audio_embed_lane_prng %}
        <div class="card preview">
          <h3>Embedding Map (Audio · PRNG Plan)</h3>
          <img class="wave" src="{{ result.audio_embed_lane_prng }}" alt="Embedding density (PRNG)">
          <p class="muted">Darker bars = more writes per time slice.</p>
        </div>
      {% endif %}

      {% if result.audio_embed_lane_diff %}
        <div class="card preview">
          <h3>Embedding Map (Audio · From Diff)</h3>
          <img class="wave" src="{{ result.audio_embed_lane_diff }}" alt="Embedding density (Diff)">
          <p class="muted">Computed from cover vs stego differences; darker = more changed bytes.</p>
        </div>
      {% endif %}

      {% if result.capacity %}
        <div class="card" style="min-width:320px;">
          <h3>Capacity Info</h3>
          <table class="kv">
            <tr><td class="key">Cover capacity</td><td>{{ result.capacity.cover_bytes }} bytes</td></tr>
            <tr><td class="key">Header size</td><td>{{ result.capacity.header_bytes }} bytes</td></tr>
            <tr><td class="key">Payload size</td><td>{{ result.capacity.payload_bytes }} bytes</td></tr>
            <tr><td class="key">Required total</td><td>{{ result.capacity.required_bytes }} bytes</td></tr>
            <tr><td class="key">Utilization</td><td>{{ result.capacity.utilization }}%</td></tr>
            <tr><td class="key">LSBs used</td><td>{{ result.capacity.n_lsb }}</td></tr>
            {% if result.capacity.hw %}<tr><td class="key">Image size</td><td>{{ result.capacity.hw }}</td></tr>{% endif %}
            {% if result.capacity.wav_fmt %}<tr><td class="key">Audio format</td><td>{{ result.capacity.wav_fmt }}</td></tr>{% endif %}
          </table>
        </div>
      {% endif %}
      {% if result and result.orig_stream_url and result.stego_stream_url %}
        <div style="display:grid;grid-template-columns:1fr 1fr;gap:16px;margin-top:16px">
          <div>
            <h3>Original (preview)</h3>
            <video controls preload="metadata" style="width:100%;max-height:360px;">
              <source src="{{ result.orig_stream_url }}" type="video/mp4" />
              Your browser does not support the video tag.
            </video>
          </div>
          <div>
            <h3>Stego (preview)</h3>
            <video controls preload="metadata" style="width:100%;max-height:360px;">
              <source src="{{ result.stego_stream_url }}" type="video/mp4" />
              Your browser does not support the video tag.
            </video>
          </div>
        </div>
        {% endif %}

        {% if result and result.download_video_url %}
          <p style="margin-top:12px">
            <a href="{{ result.download_video_url }}" class="btn btn-primary">
              Download True Stego (lossless)
            </a>
          </p>
        {% endif %}

    </div>

    {% if result.download_url %}
      <p><a class="btn" href="{{ result.download_url }}">Download stego image</a></p>
    {% endif %}
    {% if result.payload_name %}
      <p><a class="btn" href="{{ url_for('download_payload') }}">Download extracted payload ({{ result.payload_name }})</a></p>
    {% endif %}
    {% if result.download_wav_url %}
      <p><a class="btn" href="{{ result.download_wav_url }}">Download stego audio</a></p>
    {% endif %}
    {% if result.download_video_url %}
      <p><a class="btn" href="{{ result.download_video_url }}">Download stego video</a></p>
    {% endif %}
  {% endif %}

  <script>
    document.querySelectorAll(".drop-zone").forEach(zone => {
      const input = zone.querySelector("input");
      const fileNameDisplay = zone.querySelector(".file-name");

      zone.addEventListener("click", () => input.click());

      zone.addEventListener("dragover", e => {
        e.preventDefault();
        zone.classList.add("dragover");
      });

      zone.addEventListener("dragleave", () => {
        zone.classList.remove("dragover");
      });

      zone.addEventListener("drop", e => {
        e.preventDefault();
        zone.classList.remove("dragover");
        if (e.dataTransfer.files.length) {
          input.files = e.dataTransfer.files;
          input.dispatchEvent(new Event('change'));
          fileNameDisplay.textContent = e.dataTransfer.files[0].name;
        }
      });

      input.addEventListener("change", () => {
        if (input.files.length) {
          fileNameDisplay.textContent = input.files[0].name;
        }
      });
    });
  </script>
  <script>
    // ====== ROI: show preview when a cover image is chosen and enable drag-select ======
    (function() {
      const coverInput = document.querySelector('form[action$="embed"] input[name="cover"]');
      const roiImgContainer = document.getElementById('roiImgContainer');
      const roiImg = document.getElementById('roiImg');
      const roiCanvas = document.getElementById('roiCanvas');
      const roiHelp = document.getElementById('roiHelp');
      const roiMeta = document.getElementById('roiMeta');

      const x1El = document.getElementById('x1');
      const y1El = document.getElementById('y1');
      const x2El = document.getElementById('x2');
      const y2El = document.getElementById('y2');
      const natWEl = document.getElementById('nat_w');
      const natHEl = document.getElementById('nat_h');

      if (!coverInput) return;

              // Add event listener to toggle the required field based on input visibility
      document.getElementById("payload").addEventListener("change", function() {
        if (this.files.length > 0) {
          document.getElementById("text_input").required = false; // Remove 'required' from text input
          document.getElementById("payload").required = true; // Make the file input required
        }
      });

      document.getElementById("text_input").addEventListener("input", function() {
        if (this.value.trim() !== "") {
          document.getElementById("payload").required = false; // Remove 'required' from file input
          document.getElementById("text_input").required = true; // Make the text input required
        }
      });

      // Load a client-side preview when a cover image is picked (click or drag&drop)
      coverInput.addEventListener('change', () => {
        const file = coverInput.files && coverInput.files[0];
        if (!file) return;

        if (!file.type.match(/^image\/(png|bmp)$/) && !file.name.match(/\.(png|bmp)$/i)) {
          roiImgContainer.style.display = 'none';
          roiHelp.style.display = 'none';
          return;
        }
        const url = URL.createObjectURL(file);
        roiImg.src = url;
        roiImg.onload = () => {
          // Natural size of the image
          const natW = roiImg.naturalWidth;
          const natH = roiImg.naturalHeight;
          natWEl.value = natW;
          natHEl.value = natH;

          // show first so layout is valid
          roiImgContainer.style.display = 'block';
          roiHelp.style.display = 'block';

          requestAnimationFrame(() => {
            const dispW = roiImg.getBoundingClientRect().width || 320;
            const scale = dispW / natW;
            const dispH = natH * scale;

            roiCanvas.width = dispW;
            roiCanvas.height = dispH;

            // Drawing state
            let dragging = false;
            let sx = 0, sy = 0, ex = 0, ey = 0;

            const ctx = roiCanvas.getContext('2d');

            function redraw() {
              ctx.clearRect(0, 0, roiCanvas.width, roiCanvas.height);
              const x = Math.min(sx, ex), y = Math.min(sy, ey);
              const w = Math.abs(ex - sx), h = Math.abs(ey - sy);
              ctx.lineWidth = 2;
              ctx.setLineDash([6, 4]);
              ctx.strokeStyle = 'rgba(0,0,0,0.85)';
              ctx.strokeRect(x, y, w, h);
              ctx.setLineDash([]);
              ctx.fillStyle = 'rgba(0,0,0,0.15)';
              ctx.fillRect(x, y, w, h);
            }

            function toNative(px, py) {
              const nx = Math.round(px / scale);
              const ny = Math.round(py / scale);
              return [nx, ny];
            }

            // helper
            function toIntOrNull(v) {
              return (v === '' || v === null || v === undefined) ? null : Number.parseInt(v, 10);
            }

            // replace your clamp or keep it, but don't call it on nulls
            function clamp(v, lo, hi){
              return Math.max(lo, Math.min(hi, v));
            }

            // Repaint rectangle using the four inputs
            function drawFromInputs() {
              // read values; keep blanks as nulls
              let nx1 = toIntOrNull(x1El.value);
              let ny1 = toIntOrNull(y1El.value);
              let nx2 = toIntOrNull(x2El.value);
              let ny2 = toIntOrNull(y2El.value);

              const natW = parseInt(natWEl.value, 10);
              const natH = parseInt(natHEl.value, 10);

              // if any is blank → treat as "no ROI": clear overlay, don't write back
              if (nx1 == null || ny1 == null || nx2 == null || ny2 == null) {
                ctx.clearRect(0, 0, roiCanvas.width, roiCanvas.height);
                roiMeta.textContent = 'No region selected (full image will be used).';
                return;
              }

              // clamp to native bounds
              nx1 = clamp(nx1, 0, natW);
              nx2 = clamp(nx2, 0, natW);
              ny1 = clamp(ny1, 0, natH);
              ny2 = clamp(ny2, 0, natH);

              // ensure proper ordering
              const left   = Math.min(nx1, nx2);
              const right  = Math.max(nx1, nx2);
              const top    = Math.min(ny1, ny2);
              const bottom = Math.max(ny1, ny2);

              // convert back to displayed coords
              sx = left  * scale;
              sy = top   * scale;
              ex = right * scale;
              ey = bottom* scale;

              // write back clamped/ordered values (keeps inputs sane)
              x1El.value = left;  y1El.value = top;
              x2El.value = right; y2El.value = bottom;

              // update meta text and redraw
              const w = Math.max(0, right - left);
              const h = Math.max(0, bottom - top);
              roiMeta.textContent = (w && h) ? `Selected ${w} × ${h} px` : `No region selected (full image will be used).`;
              redraw();
            }

            // Listen for manual edits (input = per keystroke; change = on blur)
            ['input','change'].forEach(evt => {
              x1El.addEventListener(evt, drawFromInputs);
              y1El.addEventListener(evt, drawFromInputs);
              x2El.addEventListener(evt, drawFromInputs);
              y2El.addEventListener(evt, drawFromInputs);
            });

            // Optional: initialize once if fields already contain values
            drawFromInputs();

            roiCanvas.onmousedown = (e) => {
              const rect = roiCanvas.getBoundingClientRect();
              dragging = true;
              sx = e.clientX - rect.left;
              sy = e.clientY - rect.top;
              ex = sx; ey = sy;
              redraw();
            };
            roiCanvas.onmousemove = (e) => {
              if (!dragging) return;
              const rect = roiCanvas.getBoundingClientRect();
              ex = e.clientX - rect.left;
              ey = e.clientY - rect.top;
              redraw();
            };
            window.addEventListener('mouseup', () => {
              if (!dragging) return;
              dragging = false;

              const left   = Math.max(0, Math.min(sx, ex));
              const top    = Math.max(0, Math.min(sy, ey));
              const right  = Math.min(roiCanvas.width,  Math.max(sx, ex));
              const bottom = Math.min(roiCanvas.height, Math.max(sy, ey));

              const [nx1, ny1] = toNative(left, top);
              const [nx2, ny2] = toNative(right, bottom);

              const w = Math.max(0, nx2 - nx1);
              const h = Math.max(0, ny2 - ny1);

              if (w && h) {
                x1El.value = nx1; y1El.value = ny1;
                x2El.value = nx2; y2El.value = ny2;
                roiMeta.textContent = `Selected ${w} × ${h} px`;
              } else {
                // clicked without dragging → treat as no ROI
                x1El.value = y1El.value = x2El.value = y2El.value = '';
                roiMeta.textContent = 'No region selected (full image will be used).';
                const ctx = roiCanvas.getContext('2d');
                ctx.clearRect(0, 0, roiCanvas.width, roiCanvas.height);
              }
            }, { once: false });
          });
        };
      });
    })();

    (function() {
      const coverAudioInput = document.querySelector('form[action$="embed_audio"] input[name="cover_wav"]');
      const roiAudioContainer = document.getElementById('roiAudioContainer');
      const roiAudio = document.getElementById('roiAudio');
      const roiAudioCanvas = document.getElementById('roiAudioCanvas');
      const roiAudioHelp = document.getElementById('roiAudioHelp');
      const roiAudioMeta = document.getElementById('roiAudioMeta');

      const startTimeEl = document.getElementById('start_time');
      const endTimeEl = document.getElementById('end_time');
      const natLengthEl = document.getElementById('nat_length');

      if (!coverAudioInput) return;

      // Load audio and draw waveform on canvas
      coverAudioInput.addEventListener('change', () => {
        const file = coverAudioInput.files && coverAudioInput.files[0];
        if (!file) return;

        if (!file.type.match(/^audio\/(wav|pcm)$/) && !file.name.match(/\.(wav|pcm)$/i)) {
          roiAudioContainer.style.display = 'none';
          roiAudioHelp.style.display = 'none';
          return;
        }
        const url = URL.createObjectURL(file);
        roiAudio.src = url;

        // When audio is loaded, decode it and draw waveform
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const analyser = audioContext.createAnalyser();

        const source = audioContext.createMediaElementSource(roiAudio);
        source.connect(analyser);
        analyser.connect(audioContext.destination);

        roiAudio.oncanplay = () => {
          const duration = roiAudio.duration;
          natLengthEl.value = duration;

          // Display the audio container and help text
          roiAudioContainer.style.display = 'block';
          roiAudioHelp.style.display = 'block';

          const ctx = roiAudioCanvas.getContext('2d');

          // Function to draw the audio waveform
          const drawWaveform = () => {
            analyser.fftSize = 2048;
            const bufferLength = analyser.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);

            analyser.getByteTimeDomainData(dataArray);

            const width = roiAudioCanvas.width;
            const height = roiAudioCanvas.height;
            ctx.clearRect(0, 0, width, height);

            const step = Math.ceil(dataArray.length / width);
            const amp = height / 2;

            for (let i = 0; i < width; i++) {
              const min = Math.min(...dataArray.slice(i * step, (i + 1) * step));
              const max = Math.max(...dataArray.slice(i * step, (i + 1) * step));
              ctx.fillRect(i, (1 + min) * amp, 1, (max - min) * amp);
            }
          };

          // Start drawing the waveform once the audio is playing
          roiAudio.play();
          drawWaveform();
          requestAnimationFrame(drawWaveform);
        };
      });
    })();
  </script>
  <script>
/* ========= One script: file name+size + capacity previews ========= */

(function () {
  // ---- Constants from your secure header/AES-GCM ----
  const FIXED_LEN = 96;   // header fixed bytes
  const TAG_LEN   = 16;   // AES-GCM tag bytes

  // ---- Helpers ----
  function formatBytes(bytes) {
    if (!Number.isFinite(bytes)) return "";
    if (bytes === 0) return "0 Bytes";
    const k = 1024;
    const sizes = ["Bytes", "KB", "MB", "GB", "TB"];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    const val = bytes / Math.pow(k, i);
    return (i === 0 ? Math.round(val) : val.toFixed(2)) + " " + sizes[i];
  }
  const enc = new TextEncoder();
  const textByteLen = (s) => enc.encode(s || "").length;

  // Make/return a small info line under a drop-zone
  function ensureInfoLine(zone) {
    if (!zone) return null;
    let info = zone.querySelector(".file-extra");
    if (!info) {
      info = document.createElement("div");
      info.className = "file-extra note";
      info.style.marginTop = "4px";
      zone.appendChild(info);
    }
    return info;
  }

  // Update .file-name inside each drop-zone to include file size
  function wireNameAndSize(zone) {
    const input = zone.querySelector('input[type="file"]');
    const nameEl = zone.querySelector(".file-name");
    if (!input || !nameEl) return;

    function update() {
      if (input.files && input.files.length) {
        const f = input.files[0];
        nameEl.textContent = `${f.name} (${formatBytes(f.size)})`;
      } else {
        nameEl.textContent = "";
      }
    }
    input.addEventListener("change", update);
    // In case an earlier script already set files and dispatched change
    update();
  }

  // Wire name+size for ALL drop-zones (works with your existing DnD script)
  document.querySelectorAll(".drop-zone").forEach(wireNameAndSize);

  // ---------- IMAGE (Embed) capacity preview ----------
  (function wireImageCapacity() {
    const form = document.querySelector('form[action$="embed"]');
    if (!form) return;

    const payloadFileInput = form.querySelector("#payload");
    const textInput        = form.querySelector("#text_input");
    const coverInput       = form.querySelector('input[name="cover"]');
    const lsbInput         = form.querySelector('input[name="lsb"]');

    const payloadZone = payloadFileInput?.closest(".drop-zone");
    const coverZone   = coverInput?.closest(".drop-zone");
    const payloadInfo = ensureInfoLine(payloadZone);
    const coverInfo   = ensureInfoLine(coverZone);

    function currentPayload() {
      if (payloadFileInput?.files?.length) {
        const f = payloadFileInput.files[0];
        return { name: f.name || "payload.bin", size: f.size, kind: "file" };
      }
      const t = (textInput?.value || "").trim();
      if (t.length) {
        return { name: "text_payload.txt", size: textByteLen(t), kind: "text" };
      }
      return null;
    }

    function requiredBytesFor(payloadName, payloadLenBytes) {
      const nlen = textByteLen(payloadName || "");
      const headerBytes = FIXED_LEN + nlen;
      const cipherBytes = payloadLenBytes + TAG_LEN;
      return headerBytes + cipherBytes;
    }

    function getImageNatDims() {
      // Your ROI image loader fills these on cover choose
      const w = parseInt(document.getElementById("nat_w")?.value || "0", 10);
      const h = parseInt(document.getElementById("nat_h")?.value || "0", 10);
      return (w > 0 && h > 0) ? { W: w, H: h } : null;
    }

    function imageCapacityBytes(W, H, nLsb, channels = 3) {
      // capacity = pixels * channels * nLsb / 8
      const capBits = BigInt(W) * BigInt(H) * BigInt(channels) * BigInt(nLsb);
      return Number(capBits / 8n);
    }

    function minPixelsFor(requiredBytes, nLsb, channels = 3) {
      // ceil( requiredBytes*8 / (channels*nLsb) )
      const num = BigInt(requiredBytes) * 8n;
      const den = BigInt(channels) * BigInt(nLsb);
      return Number((num + den - 1n) / den);
    }

    function squareSuggestion(nPixels) {
      const s = Math.ceil(Math.sqrt(nPixels));
      return `${s}×${s}`;
    }

    function recompute() {
      const nLsb = Math.max(1, Math.min(8, parseInt(lsbInput?.value || "1", 10)));
      const payload = currentPayload();

      // Payload info line
      if (payloadInfo) {
        if (!payload) {
          payloadInfo.textContent = "";
        } else {
          const req = requiredBytesFor(payload.name, payload.size);
          const minPix = minPixelsFor(req, nLsb, 3);
          payloadInfo.textContent =
            `Selected: ${payload.name} (${formatBytes(payload.size)}). ` +
            `Needs cover file ≥ ${formatBytes(req)} capacity ` +
            `(min ~ ${minPix.toLocaleString()} px @ ${nLsb} LSBs, ≈ ${squareSuggestion(minPix)}).`;
        }
      }

      // Cover capacity line (if cover chosen and nat dims known)
      if (coverInfo) {
        const dims = getImageNatDims();
        if (!dims) {
          coverInfo.textContent = "";
        } else {
          const cap = imageCapacityBytes(dims.W, dims.H, nLsb, 3);
          if (payload) {
            const req = requiredBytesFor(payload.name, payload.size);
            const status = (cap >= req) ? "OK" : "Too small";
            coverInfo.textContent =
              `Cover ≈ ${dims.W}×${dims.H} @ ${nLsb} LSBs → capacity ${formatBytes(cap)} (${status}).`;
          } else {
            coverInfo.textContent =
              `Cover ≈ ${dims.W}×${dims.H} @ ${nLsb} LSBs → capacity ${formatBytes(cap)}.`;
          }
        }
      }
    }

    // Events
    payloadFileInput?.addEventListener("change", recompute);
    textInput?.addEventListener("input", recompute);
    lsbInput?.addEventListener("input", recompute);
    lsbInput?.addEventListener("change", recompute);

    // When cover changes, your ROI loader fills nat_w/nat_h on load—recompute after a tick
    coverInput?.addEventListener("change", () => setTimeout(recompute, 0));

    recompute();
  })();

  // ---------- AUDIO: show payload size + required bytes ----------
  function wireSimpleRequired(formSelector, payloadSelector) {
    const form = document.querySelector(formSelector);
    if (!form) return;
    const payload = form.querySelector(payloadSelector);
    const zone = payload?.closest(".drop-zone");
    const info = ensureInfoLine(zone);

    function recompute() {
      if (!payload || !info) return;
      if (payload.files && payload.files.length) {
        const f = payload.files[0];
        const req = (FIXED_LEN + textByteLen(f.name || "")) + (f.size + TAG_LEN);
        info.textContent =
          `Selected: ${f.name} (${formatBytes(f.size)}). ` +
          `Needs cover capacity ≥ ${formatBytes(req)}.`;
      } else {
        info.textContent = "";
      }
    }
    payload?.addEventListener("change", recompute);
    recompute();
  }

  wireSimpleRequired('form[action$="embed_video"]', 'input[name="payload_video"]');
})();
</script>
<script>
/* ---------- AUDIO (WAV): capacity with ROI + min duration hint ---------- */
(function () {
  const FIXED_LEN = 96;   // header fixed bytes (same as backend)
  const TAG_LEN   = 16;   // AES-GCM tag

  // Reuse helpers from your main script if present; fallback versions here:
  const enc = window.TextEncoder ? new TextEncoder() : null;
  const textByteLen = (s) => enc ? enc.encode(s || "").length : (s || "").length;
  function formatBytes(bytes) {
    if (!Number.isFinite(bytes)) return "";
    if (bytes === 0) return "0 Bytes";
    const k = 1024, sizes = ["Bytes","KB","MB","GB","TB"];
    const i = Math.floor(Math.log(bytes)/Math.log(k));
    const v = bytes/Math.pow(k,i);
    return (i===0 ? Math.round(v) : v.toFixed(2))+" "+sizes[i];
  }

  // Make/return a small info line under a drop-zone
  function ensureInfoLine(zone) {
    if (!zone) return null;
    let info = zone.querySelector(".file-extra");
    if (!info) {
      info = document.createElement("div");
      info.className = "file-extra note";
      info.style.marginTop = "4px";
      zone.appendChild(info);
    }
    return info;
  }

  // Parse WAV header (RIFF) just enough to get byteRate & blockAlign.
  // Works for standard PCM WAV.
  function readWavHeader(file) {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      // Read first 128 bytes (more than enough for RIFF + "fmt " chunk).
      const blob = file.slice(0, 128);
      reader.onload = () => {
        try {
          const buf = reader.result;
          const dv  = new DataView(buf);

          // "RIFF" (0-3), "WAVE" (8-11)
          if (dv.getUint32(0, false) !== 0x52494646 || dv.getUint32(8, false) !== 0x57415645) {
            throw new Error("Not a RIFF/WAVE file");
          }

          // Find the "fmt " chunk
          let off = 12;
          let byteRate = null;
          let blockAlign = null;
          while (off + 8 <= dv.byteLength) {
            const chunkId = dv.getUint32(off, false);
            const chunkSz = dv.getUint32(off + 4, true);
            off += 8;
            if (chunkId === 0x666d7420) { // "fmt "
              // audioFormat(2), numChannels(2), sampleRate(4), byteRate(4), blockAlign(2), bitsPerSample(2)
              const audioFormat = dv.getUint16(off, true);
              const numChannels = dv.getUint16(off + 2, true);
              const sampleRate  = dv.getUint32(off + 4, true);
              byteRate   = dv.getUint32(off + 8, true);
              blockAlign = dv.getUint16(off + 12, true);
              // basic sanity
              if (audioFormat !== 1 && audioFormat !== 65534) {
                // 1=PCM, 65534=WAVE_FORMAT_EXTENSIBLE (often PCM too)
              }
              break;
            } else {
              off += chunkSz;
            }
          }
          if (!byteRate || !blockAlign) throw new Error("fmt chunk not found");
          resolve({ byteRate, blockAlign });
        } catch (e) { reject(e); }
      };
      reader.onerror = () => reject(reader.error);
      reader.readAsArrayBuffer(blob);
    });
  }

  function requiredBytesFor(name, payloadLenBytes) {
    const nlen = textByteLen(name || "");
    const headerBytes = FIXED_LEN + nlen;
    const cipherBytes = payloadLenBytes + TAG_LEN;
    // For audio, your backend embeds HEADER+PAYLOAD together in the ROI.
    return headerBytes + cipherBytes;
  }

  const form = document.querySelector('form[action$="embed_audio"]');
  if (!form) return;

  const coverInput   = form.querySelector('input[name="cover_wav"]');
  const payloadInput = form.querySelector('input[name="payload_wav"]');
  const lsbInput     = form.querySelector('input[name="lsb"]');
  const startEl      = form.querySelector('#start_time');
  const endEl        = form.querySelector('#end_time');

  const coverZone   = coverInput?.closest(".drop-zone");
  const payloadZone = payloadInput?.closest(".drop-zone");
  const coverInfo   = ensureInfoLine(coverZone);
  const payloadInfo = ensureInfoLine(payloadZone);

  let wavMeta = null; // {byteRate, blockAlign}
  let audioDuration = null;

  // Try to read duration from the <audio id="roiAudio"> element you already have
  const audioEl = document.getElementById('roiAudio');
  if (audioEl) {
    audioEl.addEventListener('loadedmetadata', () => {
      audioDuration = audioEl.duration || null;
      recompute();
    });
  }

  function currentPayload() {
    if (payloadInput?.files?.length) {
      const f = payloadInput.files[0];
      return { name: f.name || 'payload.bin', size: f.size };
    }
    return null;
  }

  function roiSeconds() {
    const st = parseFloat(startEl?.value || ""); 
    const et = parseFloat(endEl?.value   || "");
    if (!Number.isFinite(st) || !Number.isFinite(et)) {
      // No ROI → use entire audio duration if known
      return audioDuration || null;
    }
    return Math.max(0, et - st);
  }

  async function recompute() {
    if (!coverInput?.files?.length) {
      coverInfo && (coverInfo.textContent = "");
      payloadInfo && (payloadInfo.textContent = "");
      return;
    }
    const nLsb = Math.max(1, Math.min(8, parseInt(lsbInput?.value || "1", 10)));
    const payload = currentPayload();

    // Show payload requirement line
    if (payloadInfo) {
      if (!payload) {
        payloadInfo.textContent = "";
      } else {
        const req = requiredBytesFor(payload.name, payload.size);
        payloadInfo.textContent =
          `Selected: ${payload.name} (${formatBytes(payload.size)}). ` +
          `Needs ≥ ${formatBytes(req)} capacity.`;
      }
    }

    // Need byteRate to compute capacity from seconds
    if (!wavMeta) {
      try {
        wavMeta = await readWavHeader(coverInput.files[0]);
      } catch {
        coverInfo && (coverInfo.textContent = "Unable to read WAV header for capacity preview.");
        return;
      }
    }
    const { byteRate, blockAlign } = wavMeta;

    // Determine region seconds (ROI or full)
    const sec = roiSeconds();
    if (sec == null) {
      coverInfo && (coverInfo.textContent = "Pick ROI start/end (or load the audio so duration is known).");
      return;
    }

    // Convert seconds → bytes (aligned like backend)
    let startByte = 0, endByte = Math.floor(sec * byteRate);
    // If explicit ROI is set, we align both ends in backend; we just mimic capacity roughly here.
    // Capacity (BYTES) in ROI = floor( roi_bytes * nLsb / 8 )
    const roiBytes = Math.max(0, endByte - startByte);
    const roiCapBytes = Math.floor((roiBytes * nLsb) / 8);

    if (!coverInfo) return;

    if (!payload) {
      coverInfo.textContent =
        `Region: ${sec.toFixed(2)}s @ ${nLsb} LSBs → capacity ${formatBytes(roiCapBytes)}.`;
      return;
    }

    const reqBytes = requiredBytesFor(payload.name, payload.size);
    if (roiCapBytes >= reqBytes) {
      coverInfo.textContent =
        `Region: ${sec.toFixed(2)}s @ ${nLsb} LSBs → capacity ${formatBytes(roiCapBytes)} (OK).`;
    } else {
      const needSec = reqBytes * 8 / (byteRate * nLsb); // invert: req = byteRate*sec*nLsb/8
      coverInfo.textContent =
        `Region: ${sec.toFixed(2)}s @ ${nLsb} LSBs → capacity ${formatBytes(roiCapBytes)} (Too small). ` +
        `Needs ≥ ${needSec.toFixed(2)}s at ${nLsb} LSBs.`;
    }
  }

  // Wire events
  [coverInput, payloadInput, lsbInput, startEl, endEl].forEach(el => {
    el?.addEventListener("change", recompute);
    el?.addEventListener("input",  recompute);
  });

  // When a new cover WAV is chosen, reset parsed header and kick off recompute
  coverInput?.addEventListener("change", () => {
    wavMeta = null;
    setTimeout(recompute, 0);
  });

  // Initial
  recompute();
})();
</script>


</body>
</html>