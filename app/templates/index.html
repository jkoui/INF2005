<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>ACW1 Stego (Web)</title>
  <style>
    body { font-family: system-ui, Arial, sans-serif; margin: 24px; }
    fieldset { margin-bottom: 24px; }
    label { display:block; margin-top: 8px; }
    .row { display:flex; gap:24px; flex-wrap: wrap; }
    .card { border:1px solid #ddd; border-radius:12px; padding:16px; }
    .preview img, .preview audio { max-width: 320px; border:1px solid #ccc; border-radius:8px; }
    .btn { padding:8px 14px; border-radius:8px; border:1px solid #333; background:#111; color:#fff; cursor:pointer;}
    .btn.secondary { background:#fff; color:#111; }
    .note { color:#666; font-size: 0.9em; }
    .flash { background:#ffe9e9; color:#900; padding:10px 12px; border-radius:8px; margin-bottom:16px; border:1px solid #f5b5b5;}
    table.kv { border-collapse: collapse; }
    table.kv td { padding:6px 10px; border-bottom:1px dashed #ddd; }
    table.kv td.key { color:#555; }
    .muted { color:#666; }
    h2 { margin-top: 0; }
    /* ROI rectangle styling */
    #roiCanvas { cursor: crosshair; }

    /* --- Drag & Drop --- */
    .drop-zone {
      border: 2px dashed #aaa;
      border-radius: 8px;
      padding: 20px;
      text-align: center;
      color: #666;
      margin-top: 8px;
      cursor: pointer;
      font-size: 0.9em;
    }
    .drop-zone.dragover {
      border-color: #333;
      background: #f9f9f9;
      color: #111;
    }
    .drop-zone input {
      display: none;
    }
    .drop-zone .file-name {
      margin-top: 8px;
      font-size: 0.85em;
      color: #333;
    }

    .input-group {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .note {
      text-align: center;
    }
  </style>
</head>
<body>
  <h1>ACW1 Stego (Web)</h1>
  {% with messages = get_flashed_messages() %}
    {% if messages %}
      {% for m in messages %}<div class="flash">{{ m }}</div>{% endfor %}
    {% endif %}
  {% endwith %}

  <div class="row">
    <div class="card" style="flex:1; min-width: 340px;">
      <h2>Embed (Image)</h2>
      <form action="{{ url_for('embed') }}" method="post" enctype="multipart/form-data">
        <label>Cover image (PNG/BMP):</label>
        <div class="drop-zone">Drag & drop or click
          <input required type="file" name="cover" accept=".png,.bmp,image/png,image/bmp">
          <div class="file-name"></div>
        </div>
        
        <div class="input-group">
        <label>Payload (any file):</label>
        <div class="drop-zone">Drag & drop or click
          <input required type="file" name="payload" id="payload">
          <div class="file-name"></div>
        </div>
        <p2 class="note">OR</p2>
        <label>Input Text for Payload:</label>
        <input type="text" name="additional_input" id="text_input" placeholder="Input Text" required>
        </div>

        <label>LSBs (1–8): <input type="number" name="lsb" min="1" max="8" value="1" required></label>
        <label>Key (integer): <input type="number" name="key" value="12345" required></label>

        <label>Bit-plane (for previews)</label>
        <select name="bit">
          <option value="0" selected>0 (LSB)</option>
          <option value="1">1</option>
          <option value="2">2</option>
          <option value="3">3</option>
          <option value="4">4</option>
          <option value="5">5</option>
          <option value="6">6</option>
          <option value="7">7 (MSB)</option>
        </select>

        <label>Channel (for previews)</label>
        <select name="channel">
          <option value="all" selected>All</option>
          <option value="r">Red</option>
          <option value="g">Green</option>
          <option value="b">Blue</option>
        </select>

        <!-- Region of Interest (optional) -->
        <fieldset style="margin-top:12px;">
          <legend>Region (optional)</legend>
          <label class="note">Leave blank to use the entire image.</label>

          <div class="row" style="align-items:flex-start;">
            <div style="min-width:320px;">
              <!-- Live preview for drawing a rectangle -->
              <div id="roiImgContainer" class="preview" style="position:relative; display:none; width:320px;">
                <img id="roiImg" style="max-width:320px; border:1px solid #ccc; border-radius:8px;">
                <canvas id="roiCanvas" style="position:absolute; inset:0; pointer-events:auto;"></canvas>
              </div>
              <div class="note" id="roiHelp" style="display:none; margin-top:6px;">
                Tip: Click-drag on the image to select a rectangle. Coordinates auto-fill below.
              </div>
            </div>

            <div>
              <label>X1 (left): <input type="number" name="x1" id="x1" min="0" step="1"></label>
              <label>Y1 (top):  <input type="number" name="y1" id="y1" min="0" step="1"></label>
              <label>X2 (right):<input type="number" name="x2" id="x2" min="0" step="1"></label>
              <label>Y2 (bottom):<input type="number" name="y2" id="y2" min="0" step="1"></label>

              <!-- Natural size of the selected cover (backend can use this to validate) -->
              <input type="hidden" name="nat_w" id="nat_w">
              <input type="hidden" name="nat_h" id="nat_h">

              <div class="note" id="roiMeta" style="margin-top:6px;"></div>
            </div>
          </div>
        </fieldset>

        <button class="btn" type="submit">Embed →</button>
      </form>
      <p class="note">Supports images (PNG/BMP).</p>
    </div>

    <div class="card" style="flex:1; min-width: 340px;">
      <h2>Extract (Image)</h2>
      <form action="{{ url_for('extract') }}" method="post" enctype="multipart/form-data">
        <label>Stego image (PNG/BMP):</label>
        <div class="drop-zone">Drag & drop or click
          <input required type="file" name="stego" accept=".png,.bmp,image/png,image/bmp">
          <div class="file-name"></div>
        </div>
        <label>LSBs (1–8): <input type="number" name="lsb" min="1" max="8" value="1" required></label>
        <label>Key (integer): <input type="number" name="key" value="12345" required></label>
        <button class="btn secondary" type="submit">Extract ←</button>
      </form>
    </div>
  </div>

  <div class="row">
    <div class="card" style="flex:1; min-width: 340px;">
      <h2>Embed (Audio WAV)</h2>
      <form action="{{ url_for('embed_audio') }}" method="post" enctype="multipart/form-data">
        <label>Cover audio (WAV/PCM 8/16-bit):</label>
        <div class="drop-zone">Drag & drop or click
          <input required type="file" name="cover_wav" accept=".wav,audio/wav">
          <div class="file-name"></div>
        </div>

        <label>Payload (any file):</label>
        <div class="drop-zone">Drag & drop or click
          <input required type="file" name="payload_wav">
          <div class="file-name"></div>
        </div>

        <label>LSBs (1–8): <input type="number" name="lsb" min="1" max="8" value="1" required></label>
        <label>Key (integer): <input type="number" name="key" value="12345" required></label>
        
        <!-- Region of Interest (audio) -->
        <fieldset style="margin-top:12px;">
          <legend>Region (optional)</legend>
          <label class="note">Leave blank to use the entire audio.</label>

          <div class="row" style="align-items:flex-start;">
            <div style="min-width:320px;">
              <!-- Live preview for drawing a region -->
              <div id="roiAudioContainer" class="preview" style="position:relative; display:block; width:320px; height: 60px;">
                <audio id="roiAudio" style="max-width:320px; border:1px solid #ccc; border-radius:8px; z-index: 10; cursor: pointer;" controls></audio>
                <canvas id="roiAudioCanvas" style="position:absolute; inset:0; pointer-events:none; z-index:0;"></canvas>
              </div>
              <div class="note" id="roiHelp" style="display:none; margin-top:6px;">
                Tip: Click-drag on the audio visualizer to select a region. Coordinates auto-fill below.
              </div>
            </div>

            <div>
              <label>Start time (seconds): <input type="number" name="start_time" id="start_time" min="0" step="0.1"></label>
              <label>End time (seconds):  <input type="number" name="end_time" id="end_time" min="0" step="0.1"></label>

              <!-- Natural length of the selected audio (backend can use this to validate) -->
              <input type="hidden" name="nat_length" id="nat_length">

              <div class="note" id="roiMetaAudio" style="margin-top:6px;"></div>
            </div>
          </div>
        </fieldset>

        <button class="btn" type="submit" style = "position:relative; z-index:10;">Embed (WAV) →</button>
      </form>
      <p class="note">Only uncompressed PCM WAV is supported.</p>
    </div>

    <div class="card" style="flex:1; min-width: 340px;">
      <h2>Extract (Audio WAV)</h2>
      <form action="{{ url_for('extract_audio') }}" method="post" enctype="multipart/form-data">
        <label>Stego audio (WAV/PCM):</label>
        <div class="drop-zone">Drag & drop or click
          <input required type="file" name="stego_wav" accept=".wav,audio/wav">
          <div class="file-name"></div>
        </div>

        <label>LSBs (1–8): <input type="number" name="lsb" min="1" max="8" value="1" required></label>
        <label>Key (integer): <input type="number" name="key" value="12345" required></label>
        <button class="btn secondary" type="submit">Extract (WAV) ←</button>
      </form>
    </div>
  </div>

  {% if result %}
    <hr>
    <h2>Result</h2>
    <div class="row">
      {% if result.cover_preview %}
        <div class="card preview">
          <h3>Cover image preview</h3>
          <img src="{{ result.cover_preview }}">
          {% if result.cover_meta %}
            <p class="muted">{{ result.cover_meta }}</p>
          {% endif %}
        </div>
      {% endif %}

      {% if result.stego_preview %}
        <div class="card preview">
          <h3>Stego image preview</h3>
          <img src="{{ result.stego_preview }}">
        </div>
      {% endif %}

      {% if result.lsb_preview %}
        <div class="card preview">
          <h3>LSB-plane preview</h3>
          <img src="{{ result.lsb_preview }}">
        </div>
      {% endif %}

      {% if result.bit_plane_preview %}
        <div class="card preview">
          <h3>Single bit-plane preview</h3>
          <img src="{{ result.bit_plane_preview }}">
        </div>
      {% endif %}

      {% if result.change_mask_preview %}
        <div class="card preview">
          <h3>LSB change mask</h3>
          <img src="{{ result.change_mask_preview }}">
        </div>
      {% endif %}

      {% if result.diff_preview %}
        <div class="card preview">
          <h3>Difference preview</h3>
          <img src="{{ result.diff_preview }}">
        </div>
      {% endif %}

      {% if result.cover_audio_preview %}
        <div class="card preview">
          <h3>Cover audio preview</h3>
          <audio controls src="{{ result.cover_audio_preview }}"></audio>
          {% if result.audio_meta %}
            <p class="muted">{{ result.audio_meta }}</p>
          {% endif %}
        </div>
      {% endif %}

      {% if result.stego_audio_preview %}
        <div class="card preview">
          <h3>Stego audio preview</h3>
          <audio controls src="{{ result.stego_audio_preview }}"></audio>
          {% if result.audio_diff_note %}
            <p class="muted">{{ result.audio_diff_note }}</p>
          {% endif %}
        </div>
      {% endif %}

      {% if result.capacity %}
        <div class="card" style="min-width:320px;">
          <h3>Capacity Info</h3>
          <table class="kv">
            <tr><td class="key">Cover capacity</td><td>{{ result.capacity.cover_bytes }} bytes</td></tr>
            <tr><td class="key">Header size</td><td>{{ result.capacity.header_bytes }} bytes</td></tr>
            <tr><td class="key">Payload size</td><td>{{ result.capacity.payload_bytes }} bytes</td></tr>
            <tr><td class="key">Required total</td><td>{{ result.capacity.required_bytes }} bytes</td></tr>
            <tr><td class="key">Utilization</td><td>{{ result.capacity.utilization }}%</td></tr>
            <tr><td class="key">LSBs used</td><td>{{ result.capacity.n_lsb }}</td></tr>
            {% if result.capacity.hw %}<tr><td class="key">Image size</td><td>{{ result.capacity.hw }}</td></tr>{% endif %}
            {% if result.capacity.wav_fmt %}<tr><td class="key">Audio format</td><td>{{ result.capacity.wav_fmt }}</td></tr>{% endif %}
          </table>
        </div>
      {% endif %}
    </div>

    {% if result.download_url %}
      <p><a class="btn" href="{{ result.download_url }}">Download stego image</a></p>
    {% endif %}
    {% if result.payload_name %}
      <p><a class="btn" href="{{ url_for('download_payload') }}">Download extracted payload ({{ result.payload_name }})</a></p>
    {% endif %}
    {% if result.download_wav_url %}
      <p><a class="btn" href="{{ result.download_wav_url }}">Download stego audio</a></p>
    {% endif %}
  {% endif %}

  <script>
    document.querySelectorAll(".drop-zone").forEach(zone => {
      const input = zone.querySelector("input");
      const fileNameDisplay = zone.querySelector(".file-name");

      zone.addEventListener("click", () => input.click());

      zone.addEventListener("dragover", e => {
        e.preventDefault();
        zone.classList.add("dragover");
      });

      zone.addEventListener("dragleave", () => {
        zone.classList.remove("dragover");
      });

      zone.addEventListener("drop", e => {
        e.preventDefault();
        zone.classList.remove("dragover");
        if (e.dataTransfer.files.length) {
          input.files = e.dataTransfer.files;
          input.dispatchEvent(new Event('change'));
          fileNameDisplay.textContent = e.dataTransfer.files[0].name;
        }
      });

      input.addEventListener("change", () => {
        if (input.files.length) {
          fileNameDisplay.textContent = input.files[0].name;
        }
      });
    });
  </script>
  <script>
    // ====== ROI: show preview when a cover image is chosen and enable drag-select ======
    (function() {
      const coverInput = document.querySelector('form[action$="embed"] input[name="cover"]');
      const roiImgContainer = document.getElementById('roiImgContainer');
      const roiImg = document.getElementById('roiImg');
      const roiCanvas = document.getElementById('roiCanvas');
      const roiHelp = document.getElementById('roiHelp');
      const roiMeta = document.getElementById('roiMeta');

      const x1El = document.getElementById('x1');
      const y1El = document.getElementById('y1');
      const x2El = document.getElementById('x2');
      const y2El = document.getElementById('y2');
      const natWEl = document.getElementById('nat_w');
      const natHEl = document.getElementById('nat_h');

      if (!coverInput) return;

              // Add event listener to toggle the required field based on input visibility
      document.getElementById("payload").addEventListener("change", function() {
        if (this.files.length > 0) {
          document.getElementById("text_input").required = false; // Remove 'required' from text input
          document.getElementById("payload").required = true; // Make the file input required
        }
      });

      document.getElementById("text_input").addEventListener("input", function() {
        if (this.value.trim() !== "") {
          document.getElementById("payload").required = false; // Remove 'required' from file input
          document.getElementById("text_input").required = true; // Make the text input required
        }
      });

      // Load a client-side preview when a cover image is picked (click or drag&drop)
      coverInput.addEventListener('change', () => {
        const file = coverInput.files && coverInput.files[0];
        if (!file) return;

        if (!file.type.match(/^image\/(png|bmp)$/) && !file.name.match(/\.(png|bmp)$/i)) {
          roiImgContainer.style.display = 'none';
          roiHelp.style.display = 'none';
          return;
        }
        const url = URL.createObjectURL(file);
        roiImg.src = url;
        roiImg.onload = () => {
          // Natural size of the image
          const natW = roiImg.naturalWidth;
          const natH = roiImg.naturalHeight;
          natWEl.value = natW;
          natHEl.value = natH;

          // show first so layout is valid
          roiImgContainer.style.display = 'block';
          roiHelp.style.display = 'block';

          requestAnimationFrame(() => {
            const dispW = roiImg.getBoundingClientRect().width || 320;
            const scale = dispW / natW;
            const dispH = natH * scale;

            roiCanvas.width = dispW;
            roiCanvas.height = dispH;

            // Drawing state
            let dragging = false;
            let sx = 0, sy = 0, ex = 0, ey = 0;

            const ctx = roiCanvas.getContext('2d');

            function redraw() {
              ctx.clearRect(0, 0, roiCanvas.width, roiCanvas.height);
              const x = Math.min(sx, ex), y = Math.min(sy, ey);
              const w = Math.abs(ex - sx), h = Math.abs(ey - sy);
              ctx.lineWidth = 2;
              ctx.setLineDash([6, 4]);
              ctx.strokeStyle = 'rgba(0,0,0,0.85)';
              ctx.strokeRect(x, y, w, h);
              ctx.setLineDash([]);
              ctx.fillStyle = 'rgba(0,0,0,0.15)';
              ctx.fillRect(x, y, w, h);
            }

            function toNative(px, py) {
              const nx = Math.round(px / scale);
              const ny = Math.round(py / scale);
              return [nx, ny];
            }

            // helper
            function toIntOrNull(v) {
              return (v === '' || v === null || v === undefined) ? null : Number.parseInt(v, 10);
            }

            // replace your clamp or keep it, but don't call it on nulls
            function clamp(v, lo, hi){
              return Math.max(lo, Math.min(hi, v));
            }

            // Repaint rectangle using the four inputs
            function drawFromInputs() {
              // read values; keep blanks as nulls
              let nx1 = toIntOrNull(x1El.value);
              let ny1 = toIntOrNull(y1El.value);
              let nx2 = toIntOrNull(x2El.value);
              let ny2 = toIntOrNull(y2El.value);

              const natW = parseInt(natWEl.value, 10);
              const natH = parseInt(natHEl.value, 10);

              // if any is blank → treat as "no ROI": clear overlay, don't write back
              if (nx1 == null || ny1 == null || nx2 == null || ny2 == null) {
                ctx.clearRect(0, 0, roiCanvas.width, roiCanvas.height);
                roiMeta.textContent = 'No region selected (full image will be used).';
                return;
              }

              // clamp to native bounds
              nx1 = clamp(nx1, 0, natW);
              nx2 = clamp(nx2, 0, natW);
              ny1 = clamp(ny1, 0, natH);
              ny2 = clamp(ny2, 0, natH);

              // ensure proper ordering
              const left   = Math.min(nx1, nx2);
              const right  = Math.max(nx1, nx2);
              const top    = Math.min(ny1, ny2);
              const bottom = Math.max(ny1, ny2);

              // convert back to displayed coords
              sx = left  * scale;
              sy = top   * scale;
              ex = right * scale;
              ey = bottom* scale;

              // write back clamped/ordered values (keeps inputs sane)
              x1El.value = left;  y1El.value = top;
              x2El.value = right; y2El.value = bottom;

              // update meta text and redraw
              const w = Math.max(0, right - left);
              const h = Math.max(0, bottom - top);
              roiMeta.textContent = (w && h) ? `Selected ${w} × ${h} px` : `No region selected (full image will be used).`;
              redraw();
            }

            // Listen for manual edits (input = per keystroke; change = on blur)
            ['input','change'].forEach(evt => {
              x1El.addEventListener(evt, drawFromInputs);
              y1El.addEventListener(evt, drawFromInputs);
              x2El.addEventListener(evt, drawFromInputs);
              y2El.addEventListener(evt, drawFromInputs);
            });

            // Optional: initialize once if fields already contain values
            drawFromInputs();

            roiCanvas.onmousedown = (e) => {
              const rect = roiCanvas.getBoundingClientRect();
              dragging = true;
              sx = e.clientX - rect.left;
              sy = e.clientY - rect.top;
              ex = sx; ey = sy;
              redraw();
            };
            roiCanvas.onmousemove = (e) => {
              if (!dragging) return;
              const rect = roiCanvas.getBoundingClientRect();
              ex = e.clientX - rect.left;
              ey = e.clientY - rect.top;
              redraw();
            };
            window.addEventListener('mouseup', () => {
              if (!dragging) return;
              dragging = false;

              const left   = Math.max(0, Math.min(sx, ex));
              const top    = Math.max(0, Math.min(sy, ey));
              const right  = Math.min(roiCanvas.width,  Math.max(sx, ex));
              const bottom = Math.min(roiCanvas.height, Math.max(sy, ey));

              const [nx1, ny1] = toNative(left, top);
              const [nx2, ny2] = toNative(right, bottom);

              const w = Math.max(0, nx2 - nx1);
              const h = Math.max(0, ny2 - ny1);

              if (w && h) {
                x1El.value = nx1; y1El.value = ny1;
                x2El.value = nx2; y2El.value = ny2;
                roiMeta.textContent = `Selected ${w} × ${h} px`;
              } else {
                // clicked without dragging → treat as no ROI
                x1El.value = y1El.value = x2El.value = y2El.value = '';
                roiMeta.textContent = 'No region selected (full image will be used).';
                const ctx = roiCanvas.getContext('2d');
                ctx.clearRect(0, 0, roiCanvas.width, roiCanvas.height);
              }
            }, { once: false });
          });
        };
      });
    })();

    (function() {
      const coverAudioInput = document.querySelector('form[action$="embed_audio"] input[name="cover_wav"]');
      const roiAudioContainer = document.getElementById('roiAudioContainer');
      const roiAudio = document.getElementById('roiAudio');
      const roiAudioCanvas = document.getElementById('roiAudioCanvas');
      const roiAudioHelp = document.getElementById('roiAudioHelp');
      const roiAudioMeta = document.getElementById('roiAudioMeta');

      const startTimeEl = document.getElementById('start_time');
      const endTimeEl = document.getElementById('end_time');
      const natLengthEl = document.getElementById('nat_length');

      if (!coverAudioInput) return;

      // Load audio and draw waveform on canvas
      coverAudioInput.addEventListener('change', () => {
        const file = coverAudioInput.files && coverAudioInput.files[0];
        if (!file) return;

        if (!file.type.match(/^audio\/(wav|pcm)$/) && !file.name.match(/\.(wav|pcm)$/i)) {
          roiAudioContainer.style.display = 'none';
          roiAudioHelp.style.display = 'none';
          return;
        }
        const url = URL.createObjectURL(file);
        roiAudio.src = url;

        // When audio is loaded, decode it and draw waveform
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const analyser = audioContext.createAnalyser();

        const source = audioContext.createMediaElementSource(roiAudio);
        source.connect(analyser);
        analyser.connect(audioContext.destination);

        roiAudio.oncanplay = () => {
          const duration = roiAudio.duration;
          natLengthEl.value = duration;

          // Display the audio container and help text
          roiAudioContainer.style.display = 'block';
          roiAudioHelp.style.display = 'block';

          const ctx = roiAudioCanvas.getContext('2d');

          // Function to draw the audio waveform
          const drawWaveform = () => {
            analyser.fftSize = 2048;
            const bufferLength = analyser.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);

            analyser.getByteTimeDomainData(dataArray);

            const width = roiAudioCanvas.width;
            const height = roiAudioCanvas.height;
            ctx.clearRect(0, 0, width, height);

            const step = Math.ceil(dataArray.length / width);
            const amp = height / 2;

            for (let i = 0; i < width; i++) {
              const min = Math.min(...dataArray.slice(i * step, (i + 1) * step));
              const max = Math.max(...dataArray.slice(i * step, (i + 1) * step));
              ctx.fillRect(i, (1 + min) * amp, 1, (max - min) * amp);
            }
          };

          // Start drawing the waveform once the audio is playing
          roiAudio.play();
          drawWaveform();
          requestAnimationFrame(drawWaveform);
        };
      });
    })();
  </script>
</body>
</html>